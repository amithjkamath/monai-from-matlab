classdef aten___convolution0 < nnet.layer.Layer & nnet.layer.Formattable & ...
        nnet.layer.AutogeneratedFromPyTorch & nnet.layer.Acceleratable
    %aten___convolution0 Auto-generated custom layer
    % Auto-generated by MATLAB on 16-Jun-2024 18:17:20
    
    properties (Learnable)
        % Networks (type dlnetwork)
        
    end
    
    properties
        % Non-Trainable Parameters
        convolution_6
        convolution_30
        convolution_31
        convolution_32
        convolution_12
        convolution_33
        convolution_9
        convolution_121
        convolution_122
        convolution_17
        convolution_171
        
        
        
    end
    
    properties (Learnable)
        % Trainable Parameters
        Param_weight
    end
    
    methods
        function obj = aten___convolution0(Name, Type, InputNames, OutputNames)
            obj.Name = Name;
            obj.Type = Type;
            obj.NumInputs = 1;
            obj.NumOutputs = 1;
            obj.InputNames = InputNames;
            obj.OutputNames = OutputNames;
        end
        
        function [convolution_input_1] = predict(obj,convolution_x_1)
            if any(dims(convolution_x_1) == 'U')
                %Validates that rank has been provided for U-labelled input
                msd_heart_model.ops.validateInput(convolution_x_1,5);
                [convolution_x_1, convolution_x_1_format] = msd_heart_model.ops.permuteInputToReversePyTorch(convolution_x_1, 5);
            else
                
                %Use the input format inferred by the importer to permute the input into reverse-PyTorch dimension order
                [convolution_x_1, convolution_x_1_format] = msd_heart_model.ops.permuteToReversePyTorch(convolution_x_1, 'BCSSS', 5);
            end
            [convolution_x_1] = struct('value', convolution_x_1, 'rank', int64(5));
            
            [convolution_input_1] = tracedPyTorchFunction(obj,convolution_x_1,false,"predict");
            
            
            [convolution_input_1] = msd_heart_model.ops.labelWithPropagatedFormats(convolution_input_1, "BCSSS");
            convolution_input_1 = convolution_input_1.value ;
            
        end
        
        
        
        function [convolution_input_1] = forward(obj,convolution_x_1)
            if any(dims(convolution_x_1) == 'U')
                %Validates that rank has been provided for U-labelled input
                msd_heart_model.ops.validateInput(convolution_x_1,5);
                [convolution_x_1, convolution_x_1_format] = msd_heart_model.ops.permuteInputToReversePyTorch(convolution_x_1, 5);
            else
                
                %Use the input format inferred by the importer to permute the input into reverse-PyTorch dimension order
                [convolution_x_1, convolution_x_1_format] = msd_heart_model.ops.permuteToReversePyTorch(convolution_x_1, 'BCSSS', 5);
            end
            [convolution_x_1] = struct('value', convolution_x_1, 'rank', int64(5));
            
            [convolution_input_1] = tracedPyTorchFunction(obj,convolution_x_1,true,"forward");
            
            
            [convolution_input_1] = msd_heart_model.ops.labelWithPropagatedFormats(convolution_input_1, "BCSSS");
            convolution_input_1 = convolution_input_1.value ;
            
        end
        
        
        
        function [convolution_input_1] = tracedPyTorchFunction(obj,convolution_x_1,isForward,predict)
            
            convolution_weight_1 = obj.Param_weight;
            
            [convolution_weight_1] = struct('value', dlarray(convolution_weight_1,'UUUUU'), 'rank', 5);
            
            [convolution_6] = msd_heart_model.ops.makeStructForConstant(double(obj.convolution_6), int64(0), "Typed");
            [convolution_30] = msd_heart_model.ops.makeStructForConstant(int64(obj.convolution_30), int64(1), "Typed");
            [convolution_31] = msd_heart_model.ops.makeStructForConstant(int64(obj.convolution_31), int64(1), "Typed");
            [convolution_32] = msd_heart_model.ops.makeStructForConstant(int64(obj.convolution_32), int64(1), "Typed");
            [convolution_12] = msd_heart_model.ops.makeStructForConstant(int64(obj.convolution_12), int64(0), "Typed");
            [convolution_33] = msd_heart_model.ops.makeStructForConstant(int64(obj.convolution_33), int64(1), "Typed");
            [convolution_9] = msd_heart_model.ops.makeStructForConstant(int64(obj.convolution_9), int64(0), "Typed");
            [convolution_121] = msd_heart_model.ops.makeStructForConstant(int64(obj.convolution_121), int64(0), "Typed");
            [convolution_122] = msd_heart_model.ops.makeStructForConstant(int64(obj.convolution_122), int64(0), "Typed");
            [convolution_17] = msd_heart_model.ops.makeStructForConstant(int64(obj.convolution_17), int64(0), "Typed");
            [convolution_171] = msd_heart_model.ops.makeStructForConstant(int64(obj.convolution_171), int64(0), "Typed");
            [convolution_input_1] = msd_heart_model.ops.pyConvolution(convolution_x_1, convolution_weight_1, convolution_6, convolution_30, convolution_31, convolution_32, convolution_12, convolution_33, convolution_9);
        end
        
    end
end

